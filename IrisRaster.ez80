IDrawPixel:
; input : hl :x , [d]e : y, c : color
; output : none
; destroyed : hl, de
	ld	d, 160	; [8]
	mlt	de		; [12]
	ex	de, hl	; [4]
	add	hl, hl	; [4]
	add	hl, de	; [4]
	ld	de, (IFramebuffer)	; [32]
	add	hl, de	; [4]
	ld	(hl), c	; [6]
	ret			; [x]
IDrawLine:
	ret

IDrawTriangle:
; (ix list of 2d coordinate)
#define	x0	0
#define	y0	3
#define	x1	4
#define	y1	7
#define	x2	8
#define	y2	11

#macro	swap(a,b)
	ld	hl, (ix+a)
	ld	de, (ix+b)
	ld	(ix+a), de
	ld	(ix+b), hl
#endmacro

	ld	a, (ix+y1)
	ld	e, (ix+y0)
	sub	a, e
	jr	nc, _INoSwap1
	add	a, e
	ld	(ix+y0), a
	ld	(ix+y1), e
	swap(x0,x1)
_INoSwap1:
	ld	a, (ix+y2)
	ld	e, (ix+y1)
	sub	a, e	
	jr	nc, _INoSwap2
	add	a, e
	ld	(ix+y2), e
	ld	(ix+y1), a
	swap(x1,x2)
_INoSwap2:
	ld	a, (ix+y1)
	ld	e, (ix+y0)
	sub	a, e
	jr	nc, _INoSwap3
	add	a, e
	ld	(ix+y0), a
	ld	(ix+y1), e
	swap(x0,x1)
_INoSwap3:
; y0<y1<y2
;	ld	hl, (ix+x1)
;	ld	de, (ix+x2)
	xor	a, a
;	sbc	hl, de
;	jr	c, $+4
;	or	a, $30
;
;	ld	c, a

; changing edges are y0-y1 and y1-y2
	ld	hl, (ix+x0)
	ld	de, (ix+x2)
	xor	a, $23			; inc hl
	sbc	hl, de
; if x0>x1, edge goes to left
	jr	c, _IEdge0
	or	a, $08			; dec hl
; edge goes to left
	ex	de, hl
	sbc	hl, hl
	sbc	hl, de
_IEdge0:	
	ld	(IDeltaX0), hl
	ld	(ISMC_Code0), a
	ld	a, (ix+y2)
	ld	e, (ix+y0)
	sub	a, e
	ld	(IDeltaY0), a
; block 0 is the constant block
;	ld	a, c
	xor	a, a
	ld	hl, (ix+x0)
	ld	de, (ix+x1)
	xor	a, $13			; inc de
	sbc	hl, de
; if x0>x1, edge goes to left
	jr	c, _IEdge1
	or	a, $08			; dec de
; edge goes to left
	ex	de, hl
	sbc	hl, hl
	sbc	hl, de
_IEdge1:	
	ld	(IDeltaX1), hl
	ld	(ISMC_Code1), a
	ld	a, (ix+y1)
	ld	e, (ix+y0)
	sub	a, e
	ld	(IDeltaY1), a
; block 1 is the variable block

	ld	hl, (ix+y0)
	ld	h, 160
	mlt	hl
	add	hl, hl
	ld	de, (ix+x0)
	add	hl, de
	ld	de, (IFramebuffer)
	add	hl, de
	ex	de, hl
	sbc	hl, hl
	add	hl, de

	push	ix
	ld	ix, (IDeltaY0)
	ld	iy, (IDeltaY1)

	or	a, a
	call	nz, __ITriangleInner__

	lea	bc, ix+0
	pop	ix
;;;;;;;;;;;;;;;;;;;;;;
	;ret
;;;;;;;;;;;;;;;;;;;;;;
	push	bc
	push	hl

	ld	hl, (ix+x1)
	ld	de, (ix+x2)
	or	a, $13			; inc de
	sbc	hl, de
; if x0>x1, edge goes to left
	jr	c, _IEdgeC1
; edge goes to left
	ld	a, $1B			; dec hl
	ex	de, hl
	sbc	hl, hl
	sbc	hl, de
_IEdgeC1:	
	ld	(IDeltaX1), hl
	ld	(ISMC_Code1), a
	ld	a, (ix+y2)
	ld	e, (ix+y1)
	sub	a, e
	ld	(IDeltaY1), a

	ld	hl, (ix+y1)
	ld	h, 160
	mlt	hl
	add	hl, hl
	ld	de, (ix+x1)
	add	hl, de
	ld	de, (IFramebuffer)
	add	hl, de
	ex	de, hl

	ld	iy, (IDeltaY1)

	pop	hl
	pop	ix
	or	a, a
	ret	z

__ITriangleInner__:

IDeltaX0=$+1
	ld	bc, $000000
	add	ix, bc
	ld	c, ixh
	rl	c
	jr	nc, __INoSignChange0__
IDeltaY0=$+1
	ld	bc, $000000
__IBlockRestoreLoop0__:
ISMC_Code0=$
	nop
	add	ix, bc
	jr	nc, __IBlockRestoreLoop0__
__INoSignChange0__:

IDeltaX1=$+1
	ld	bc, $000000
	add	iy, bc
	ld	c, iyh
	rl	c
	jr	nc, __INoSignChange1__
IDeltaY1=$+1
	ld	bc, $000000
__IBlockRestoreLoop1__:
ISMC_Code1=$
	nop
	add	iy, bc	
	jr	nc, __IBlockRestoreLoop1__
__INoSignChange1__:
; hl = adress1, de = adress2
	push	hl
	or	a, a
	sbc	hl, de
	jr	z, _ISpecial
	push	de
	jr	nc, _IDrawLine
	add	hl, de
	ex	de, hl
	or	a, a
	sbc	hl, de
_IDrawLine:
; de= right point, hl = size
	inc.s	bc	; hack to clear bcu faster than ld bc,0
	ld	b, h
	ld	c, l
	sbc	hl, hl
	add	hl, de
IColor=$+1
	ld	(hl), 255
	inc	de
	ldir
	pop	de
_IEndFill:
	pop	hl
	ld	bc, 320
	add	hl, bc
	ex	de, hl
	add	hl, bc
	ex	de, hl
	dec	a
	jr	nz, __ITriangleInner__
	ret
_ISpecial:
	ld	c, a
	ld	a, (IColor)
	ld	(de), a
	ld	a, c
	jr	_IEndFill