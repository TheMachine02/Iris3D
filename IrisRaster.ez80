IDrawPixel:
; input : hl :x , [d]e : y, c : color
; output : none
; destroyed : hl, de
	ld	d, 160	; [8]
	mlt	de		; [12]
	ex	de, hl	; [4]
	add	hl, hl	; [4]
	add	hl, de	; [4]
	ld	de, (IFramebuffer)	; [32]
	add	hl, de	; [4]
	ld	(hl), c	; [6]
	ret			; [x]
IDrawLine:
	ret

IDrawTriangle:
; (ix list of 2d coordinate)
#define	x0	0
#define	y0	3
#define	x1	4
#define	y1	7
#define	x2	8
#define	y2	11

	ld	hl, (ix+0)
	ld	de, (ix+3)
	ld	bc, (ix+6)

	ld	a, (de)
	sub	a, (hl)
	jr	c, _INoSwap1
	ex	de, hl
_INoSwap1:
	ld	a, (bc)
	sub	a, (hl)
	jr	nc, _INoSwap2
	push	hl
	or	a, a
	sbc	hl, hl
	add	hl, bc
	pop	bc
_INoSwap2:
	ld	a, (de)
	sub	a, (hl)
	jr	c, _INoSwap3
	ex	de, hl
_INoSwap3:
	ld	ix, ITmpAdress
	ld	(ix+0), de
	ld	(ix+3), hl
	ld	(ix+6), bc
	ex	de, hl

	ld	a, (bc)
	sub	a, (hl)
	ld	(IDeltaY0), a
	xor	a, a

; changing edges are y0-y1 and y1-y2
	ld	iy, (ix+6)
	ld	de, (iy+1)
	inc	hl
	ld	hl, (hl)
	xor	a, $23			; inc hl
	sbc	hl, de
; if x0>x1, edge goes to left
	jr	c, _IEdge0
	or	a, $08			; dec hl
; edge goes to left
	ex	de, hl
	sbc	hl, hl
	sbc	hl, de
_IEdge0:	
	ld	(IDeltaX0), hl
	ld	(ISMC_Code0), a
; block 0 is the constant block

;	ld	a, $EB
;	ld	(ISMC_Ex), a
;	xor	a, a
;	ld	(ISMC_Nop), a


	xor	a, a
;	ld	hl, (ix+3)
;	inc	hl
;	ld	de, (hl)
	ld	iy, (ix+3)
	ld	de, (iy+1)
	ld	hl, (ix+0)
	inc	hl
	ld	hl, (hl)
	xor	a, $13			; inc de
	sbc	hl, de
; if x0>x1, edge goes to left
	jr	c, _IEdge1
	or	a, $08			; dec de
; edge goes to left
	ex	de, hl
	sbc	hl, hl
	sbc	hl, de
_IEdge1:	
	ld	(IDeltaX1), hl
	ld	(ISMC_Code1), a
;	ld	hl, (ix+3)
;	ld	a, (hl)
	ld	a, (iy+0)
	ld	hl, (ix+0)
	sub	a, (hl)
	ld	(IDeltaY1), a
	ld	iy, 0
	ld	iyl, a
; block 1 is the variable block

	ld	e, (hl)
	ld	d, 160
	mlt	de
	inc	hl
	ld	hl, (hl)
	add	hl, de
	add	hl, de
	ld	de, (IFramebuffer)
	add	hl, de
	ex	de, hl
	sbc	hl, hl
	add	hl, de

	ld	ix, (IDeltaY0)

	or	a, a
	call	nz, __ITriangleInner__

;;;;;;;;;;;;;;;;;;;;;;
;	ret
;;;;;;;;;;;;;;;;;;;;;;

	push	hl
	ld	iy, ITmpAdress
	ld	hl, (iy+6)
	ld	a, (hl)
	inc	hl
	ld	de, (hl)
	ld	hl, (iy+3)
	sub	(hl)
	ld	(IDeltaY1), a
	ld	c, a
	inc	hl
	ld	hl, (hl)
	sbc	hl, de
	ld	a, $13
; if x0>x1, edge goes to left
	jr	c, _IEdgeC1
; edge goes to left
	ld	a, $1B			; dec hl
	ex	de, hl
	sbc	hl, hl
	sbc	hl, de
_IEdgeC1:	
	ld	(IDeltaX1), hl
	ld	(ISMC_Code1), a
	ld	hl, (iy+3)
	ld	iy, 0
	ld	a, c
	ld	iyl, a
	ld	e, (hl)
	ld	d, 160
	mlt	de
	inc	hl
	ld	hl, (hl)
	add	hl, de
	add	hl, de
	ld	de, (IFramebuffer)
	add	hl, de
	ex	de, hl
	pop	hl
	or	a, a
	ret	z
__ITriangleInner__:
IDeltaX0=$+1
	ld	bc, $000000
	add	ix, bc
	ld	c, ixh
	rl	c
	jr	nc, __INoSignChange0__
IDeltaY0=$+1
	ld	bc, $000000
__IBlockRestoreLoop0__:
ISMC_Code0=$
	nop
	add	ix, bc
	jr	nc, __IBlockRestoreLoop0__
__INoSignChange0__:
IDeltaX1=$+1
	ld	bc, $000000
	add	iy, bc
	ld	c, iyh
	rl	c
	jr	nc, __INoSignChange1__
IDeltaY1=$+1
	ld	bc, $000000
__IBlockRestoreLoop1__:
ISMC_Code1=$
	nop
	add	iy, bc	
	jr	nc, __IBlockRestoreLoop1__
	or	a, a
__INoSignChange1__:
; hl = adress1, de = adress2
	push	hl
	sbc	hl, de
	jr	z, _ISpecial
	push	de
	jr	nc, _IDrawLine
	add	hl, de
	ex	de, hl
	or	a, a
	sbc	hl, de
_IDrawLine:
; de= right point, hl = size
	inc.s	bc	; hack to clear bcu faster than ld bc,0
	ld	b, h
	ld	c, l
	sbc	hl, hl
	add	hl, de
IColor=$+1
	ld	(hl), 255
	inc	de
	ldir
	pop	de
_IEndFill:
	pop	hl
	ld	bc, 320
	add	hl, bc
	ex	de, hl
	add	hl, bc
	ex	de, hl
	dec	a
	jr	nz, __ITriangleInner__
	ret
_ISpecial:
	ld	c, a
	ld	a, (IColor)
	ld	(de), a
	ld	a, c
	jr	_IEndFill
ITmpAdress:
	.dl	0,0,0

#comment
	push	hl
	push	de
	sbc	hl, de
	jr	nc, _ISwap
	add	hl, de
	ex	de, hl
	or	a, a
	sbc	hl, de
_ISwap:
	inc.s	bc
	ld	b, h
	ld	c, l
	add	hl, de
IColor=$+1
	ld	(hl), $00
	jr	z, _ILineNull
	ex	de, hl
	sbc	hl, hl
	add	hl, de
	dec	de
	lddr
_ILineNull:
	pop	de
	pop	hl



ISMC_Nop=$
	nop
	sbc	hl, de
	jr	c, _ISwap
_IEntryPoint:
	inc.s	bc
	ld	b, h
	ld	c, l
	add	hl, de
IColor=$+1
	ld	(hl), $00
	jr	z, _ILineNull
	push	hl
	ex	de, hl
	sbc	hl, hl
	add	hl, de
	dec	de
	lddr
	inc	de
	pop	hl
_ILineNull:
	ld	c, 64
	inc	b
	add	hl, bc
	ex	de, hl
	add	hl, bc
ISMC_Ex=$
	ex	de, hl
	dec	a
	jr	nz, __ITriangleInner__
	ret
_ISwap:
; 84 TStates overhead
	ld	c, a
	ld	a, $EB
	ld	(ISMC_Nop), a
	xor	a, a
	ld	(ISMC_Ex), a
	add	hl, de
	ex	de, hl
	sbc	hl, de
	ld	a, c
	jr	_IEntryPoint
ITmpAdress:
	.dl	0,0,0
#endcomment
