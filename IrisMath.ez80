IReciprocal:
	push	hl
	pop	bc
	ld	hl, $2
	sbc hl,bc \ jr nc,$+3 \ add hl,bc \ adc a,a
	add hl,hl \ sbc hl,bc \ jr nc,$+3 \ add hl,bc \ adc a,a
	add hl,hl \ sbc hl,bc \ jr nc,$+3 \ add hl,bc \ adc a,a
	add hl,hl \ sbc hl,bc \ jr nc,$+3 \ add hl,bc \ adc a,a
	add hl,hl \ sbc hl,bc \ jr nc,$+3 \ add hl,bc \ adc a,a
	add hl,hl \ sbc hl,bc \ jr nc,$+3 \ add hl,bc \ adc a,a
	add hl,hl \ sbc hl,bc \ jr nc,$+3 \ add hl,bc \ adc a,a
	add hl,hl \ sbc hl,bc \ jr nc,$+3 \ add hl,bc \ adc a,a
	cpl
	ld	d, a
	add hl,hl \ sbc hl,bc \ jr nc,$+3 \ add hl,bc \ adc a,a
	add hl,hl \ sbc hl,bc \ jr nc,$+3 \ add hl,bc \ adc a,a
	add hl,hl \ sbc hl,bc \ jr nc,$+3 \ add hl,bc \ adc a,a
	add hl,hl \ sbc hl,bc \ jr nc,$+3 \ add hl,bc \ adc a,a
	add hl,hl \ sbc hl,bc \ jr nc,$+3 \ add hl,bc \ adc a,a
	add hl,hl \ sbc hl,bc \ jr nc,$+3 \ add hl,bc \ adc a,a
	add hl,hl \ sbc hl,bc \ jr nc,$+3 \ add hl,bc \ adc a,a
	add hl,hl \ sbc hl,bc \ jr nc,$+3 \ add hl,bc \ adc a,a
	cpl
	ld	e, a
	ex	de, hl
	;slhl	8
	add	hl, hl
	add	hl, hl
	add	hl, hl
	add	hl, hl
	add	hl, hl
	add	hl, hl
	add	hl, hl
	add	hl, hl
	ex	de, hl
	add hl,hl \ sbc hl,bc \ jr nc,$+3 \ add hl,bc \ adc a,a
	add hl,hl \ sbc hl,bc \ jr nc,$+3 \ add hl,bc \ adc a,a
	add hl,hl \ sbc hl,bc \ jr nc,$+3 \ add hl,bc \ adc a,a
	add hl,hl \ sbc hl,bc \ jr nc,$+3 \ add hl,bc \ adc a,a
	add hl,hl \ sbc hl,bc \ jr nc,$+3 \ add hl,bc \ adc a,a
	add hl,hl \ sbc hl,bc \ jr nc,$+3 \ add hl,bc \ adc a,a
	add hl,hl \ sbc hl,bc \ jr nc,$+3 \ add hl,bc \ adc a,a
	add hl,hl \ sbc hl,bc \ jr nc,$+3 \ add hl,bc \ adc a,a
	cpl
	ld	e, a
	ex	de, hl
	ret
ISquareRoot:
    xor a \ ld b,l \ push bc \ ld b,a \ ld d,a \ ld c,a \ ld l,a \ ld e,a
;Iteration 1
    add hl,hl \ rl c \ add hl,hl \ rl c
    sub c \ jr nc,$+6 \ inc e \ inc e \ cpl \ ld c,a
;Iteration 2
    add hl,hl \ rl c \ add hl,hl \ rl c \ rl e \ ld a,e
    sub c \ jr nc,$+6 \ inc e \ inc e \ cpl \ ld c,a
;Iteration 3
    add hl,hl \ rl c \ add hl,hl \ rl c \ rl e \ ld a,e
    sub c \ jr nc,$+6 \ inc e \ inc e \ cpl \ ld c,a
;Iteration 4
    add hl,hl \ rl c \ add hl,hl \ rl c \ rl e \ ld a,e
    sub c \ jr nc,$+6 \ inc e \ inc e \ cpl \ ld c,a
;Iteration 5
    add hl,hl \ rl c \ add hl,hl \ rl c \ rl e \ ld a,e
    sub c \ jr nc,$+6 \ inc e \ inc e \ cpl \ ld c,a
;Iteration 6
    add hl,hl \ rl c \ add hl,hl \ rl c \ rl e \ ld a,e
    sub c \ jr nc,$+6 \ inc e \ inc e \ cpl \ ld c,a

;Iteration 7
    add hl,hl \ rl c \ add hl,hl \ rl c \ rl b
    ex de,hl \ add hl,hl \ push hl \ sbc hl,bc \ jr nc,$+8
    ld a,h \ cpl \ ld b,a
    ld a,l \ cpl \ ld c,a
    pop hl
    jr nc,$+4 \ inc hl \ inc hl
    ex de,hl
;Iteration 8
    add hl,hl \ ld l,c \ ld h,b \ adc hl,hl \ adc hl,hl
    ex de,hl \ add hl,hl \ sbc hl,de \ add hl,de \ ex de,hl
    jr nc,$+6 \ sbc hl,de \ inc de \ inc de
;Iteration 9
    pop af
    rla \ adc hl,hl \ rla \ adc hl,hl
    ex de,hl \ add hl,hl \ sbc hl,de \ add hl,de \ ex de,hl
    jr nc,$+6 \ sbc hl,de \ inc de \ inc de
;Iteration 10
    rla \ adc hl,hl \ rla \ adc hl,hl
    ex de,hl \ add hl,hl \ sbc hl,de \ add hl,de \ ex de,hl
    jr nc,$+6 \ sbc hl,de \ inc de \ inc de
;Iteration 11
    rla \ adc hl,hl \ rla \ adc hl,hl
    ex de,hl \ add hl,hl \ sbc hl,de \ add hl,de \ ex de,hl
    jr nc,$+6 \ sbc hl,de \ inc de \ inc de
;Iteration 12
    rla \ adc hl,hl \ rla \ adc hl,hl
    ex de,hl \ add hl,hl \ sbc hl,de \ add hl,de \ ex de,hl
    jr nc,$+6 \ sbc hl,de \ inc de \ inc de
    rr d \ rr e \ ld a,$B7 \ jr nc,+_ \ xor a,%10000000
_:	ld (Div_SMC),a
;Iteration 13 (new)
    add hl,hl \ add hl,hl
    ex de,hl \ add hl,hl \ sbc hl,de \ add hl,de \ ex de,hl
    jr nc,$+6 \ sbc hl,de \ inc de \ inc de
;Iteration 14
    add hl,hl \ add hl,hl
    ex de,hl \ add hl,hl \ sbc hl,de \ add hl,de \ ex de,hl
    jr nc,$+6 \ sbc hl,de \ inc de \ inc de
;Iteration 15
    add hl,hl \ add hl,hl
    ex de,hl \ add hl,hl \ sbc hl,de \ add hl,de \ ex de,hl
    jr nc,$+6 \ sbc hl,de \ inc de \ inc de
;Iteration 16
    add hl,hl \ add hl,hl
    ex de,hl \ add hl,hl \ sbc hl,de \ add hl,de \ ex de,hl
    jr nc,$+6 \ sbc hl,de \ inc de \ inc de
Div_SMC:	or a,a
	rl e \ ret

IFPMul:
; HLxDE/256 [16bits]
; (HxD*256+LxD+ExH+LxE/256)
	ld	b, h
	ld	c, l
	ld	l, d
	mlt	hl
	bit	7, b
	jr	z, $+5
	or	a, a
	sbc	hl, de
	bit	7, d
	jr	z, $+5
	or	a, a
	sbc	hl, bc
	slhl
; now need to do (CxD+BxE+ExC/256)
	ld	a, c
	ld	c, e
	mlt	bc
	add	hl, bc
	ld	c, a
	ld	b, d
	mlt	bc
	add	hl, bc
	ld	c, a
	ld	b, e
	mlt	bc
	ld	c, b
	ld	b, 0
	add	hl, bc
	ret
IFPSquare:
; HL²/256
; Destroy DE,A [16bits]
; (HxH*256+LxH*2+LxL/256)
	bit	7, h
	jr	z, _IFPSAbsSkp
	ex	de, hl
	or	a, a
	sbc	hl, hl
	sbc	hl, de
_IFPSAbsSkp:
	ld	d, h
	ld	e, l
	ld	l, h
	mlt	hl
	slhl
	ld	a, e
	mlt	de
	add	hl, de
	add	hl, de
	ld	e, a
	ld	d, a
	mlt	de
	ld	e, d
	ld	d, 0
	add	hl, de
	ret
IFPCos:
	inc	h
IFPSin:
	call	IQuatSin
; divide by 64 to get a FP16.8 value
	add	hl, hl
	add	hl, hl
	ld	a, hlu
	ld	c, h
	add	hl, hl
	sbc	hl, hl
	ld	h, a
	ld	l, c
	ret
IComputeDepthList:
	lea	ix, ix+7
	ld	a, c
	dec	bc
	inc	b
	ld	c, a
	ld	a, b
	ld	b, c
_IDepthLoop:

	ld	iy, (ix+0)
	ld	de, (iy+4)
	ex	de, hl

	ld	iy, (ix+3)
	ld	de, (iy+4)
	add	hl, de

	ld	iy, (ix+6)
	ld	de, (iy+4)
	add	hl, de
	
	ld	(ix-7), hl
	lea	ix, ix+16
	djnz	_IDepthLoop
	dec	a
	jr	nz, _IDepthLoop
	ret
IInsertionSort:
#comment
for (i = 1; i < arr.length; i++) {
    newValue = arr[i]; ; compute the Z average distance.
    j = i;
    while (j > 0 && arr[j - 1] > newValue) {
        arr[j] = arr[j - 1];
        j--;
    }
arr[j] = newValue; 
#endcomment
; array = ix, each element are (9id+1col+3key)=13 bytes in size
; ix =array, bc=length
; loop calculation
	dec	bc
	ld	a, c
	dec	bc
	inc	b
; bound check smc
	lea	de, ix-15
	sbc	hl, hl
	sbc	hl, de
	ld	(ISort_SMC), hl
_ISortOuterLoop:
	push	bc
_ISortInnerLoop:
	lea	ix, ix+16
	ld	de, (ix+0) ;de
	lea	iy, ix+0
ISort_SMC=$+1
	ld	bc, $000000
_ISortWhile:
	lea	iy, iy-16
	ld	hl, (iy+0)
	or	a, a
	sbc	hl, de
	jr	nc, _ISortQuit
	lea	hl, iy
	add	hl, bc
	jr	c, _ISortWhile
_ISortQuit:
	lea	hl, ix+0
	lea	de, iy+16
	sbc	hl, de
	jr	z, _ISortNoCopy
	push	hl
	add	hl, de
	ld	de, ITmpBlock
	ld	bc, 16
	ldir
	pop	bc
	lea	hl, ix-1
	lea	de, ix+15
	lddr
	ex	de, hl
	inc	de
	ld	hl, ITmpBlock
	ld	c, 16
	ldir
_ISortNoCopy:
	dec	a
	jr	nz, _ISortInnerLoop
	pop	bc
	djnz	_ISortOuterLoop
	ret
ITmpBlock:
	.dl	0,0,0,0,0,0

#comment
; array = ix, each element are (9id+1col+3key)=13 bytes in size
; ix =array, bc=length
	lea	de, ix+1
	or	a, a
	sbc	hl, hl
	sbc	hl, de
	ld	(ISort_SMC), hl
	dec	bc
_ISortLoop:
	lea	ix, ix+13
	dec	bc
	push	bc
	ld	de, ITmpBlock
	lea	hl, ix+0
	ld	bc, 13
	ldir
	ld	hl, (ix+0)
	lea	iy, ix+0
	halt
_ISortWhile:
	ld	de, (iy-13)
	or	a, a
	sbc	hl, de
	jr	c, _ISortQuit
	add	hl, de
	push	iy
ISort_SMC=$+1
	ld	bc, $000000
	add	iy, bc
	pop	iy
	jr	nc, _ISortQuit
	push	hl
	lea	hl, iy-13
	lea	de, iy
	lea	iy, iy-13
	ld	bc, 13
	ldir
	pop	hl
	jr	_ISortWhile
_ISortQuit:
	lea	de, iy+0
	ld	hl, ITmpBlock
	ld	bc, 13
	ldir

	pop	bc
	ld	a, b
	or	c
	jr	nz, _ISortLoop
	ret
ITmpBlock:
	.dl	0,0,0,0,0
#endcomment





