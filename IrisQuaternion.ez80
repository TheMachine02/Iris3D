#if	IVERSION==$0100

; code start - Quaternions utility functions

#macro	__IQuatMul__()
	call	IFPMul
	add	hl, hl
	rra
	add	hl, hl
	ld	(__iwritetmp__), hl
	rla
	ld	a, (__iwritetmp__+2)
	ld	c, h
	sbc	hl, hl
	ld	h, a
	ld	l, c
	ld	a, (__iwritetmp__)	
#endmacro
#define	IQuatMul		__IQuatMul__()

#macro	__iquatsquare__()
	call	IFPSquare
	add	hl, hl
	rra
	add	hl, hl
	ld	(__iwritetmp__), hl
	rla
	ld	a, (__iwritetmp__+2)
	ld	c, h
	sbc	hl, hl
	ld	h, a
	ld	l, c
	ld	a, (__iwritetmp__)
#endmacro

#ifdef	IUSE_FN_QUATLOADIDENTITY
IQuaternionLoadIdentity:
	ex	de, hl
	ld	hl, IIdentityQuaternion
	ld	bc, IQUATERNION_SIZE
	ldir
	ex	de, hl
	ld	bc, -IQUATERNION_SIZE
	add	hl, bc
	ret
#endif
#ifdef	IUSE_FN_QUATLOADROTATION
IQuaternionLoadRotation:
	ret
#endif
#ifdef	IUSE_FN_QUATMULT
IQuaternionMult:
	ret
#endif
#ifdef	IUSE_FN_QUATMAGNITUDE
IQuaternionMagnitude:
	ret
#endif
#ifdef	IUSE_FN_QUATCONJUGATE
IQuaternionConjugate:
	ld	de, (ix+3)
	or	a, a
	sbc	hl, hl
	sbc	hl, de
	ld	(ix+3), hl
	ld	de, (ix+6)
	or	a, a
	sbc	hl, hl
	sbc	hl, de
	ld	(ix+6), hl
	ld	de, (ix+9)
	or	a, a
	sbc	hl, hl
	sbc	hl, de
	ld	(ix+9), hl
	ret
#endif
#ifdef	IUSE_FN_QUATNORMALIZE
IQuaternionNormalize:
	ret
#endif
#ifdef	IUSE_FN_QUATGETMATRIX
#define	IQuatSquare	__iquatsquare__()
IQuaternionGetMatrix:
; iy quaternion, ix matrix
; (qw, qx, qy, qz)
; 1 - 2*qy² - 2*qz² 	2*qx*qy - 2*qz*qw 	2*qx*qz + 2*qy*qw
; 2*qx*qy + 2*qz*qw 	1 - 2*qx² - 2*qz² 	2*qy*qz - 2*qx*qw
; 2*qx*qz - 2*qy*qw 	2*qy*qz + 2*qx*qw 	1 - 2*qx² - 2*qy²
	ld	hl, (iy+IQZ)
	ld	de, (iy+IQW)
	IQuatMul
	rla
	adc	hl, hl
; 2*qz*qw
	push	hl
	ld	hl, (iy+IQX)
	ld	de, (iy+IQY)
	IQuatMul
	rla
	adc	hl, hl
; 2*qx*qy
	pop	de
	or	a, a
	sbc	hl, de
	ld	(ix+1), h
	add	hl, de
	add	hl, de
	ld	(ix+3), h
; next
	ld	hl, (iy+IQY)
	ld	de, (iy+IQW)
	IQuatMul
	rla
	adc	hl, hl
; 2*qw*qy
	push	hl
	ld	hl, (iy+IQX)
	ld	de, (iy+IQZ)
	IQuatMul
	rla
	adc	hl, hl
; 2*qx*qz
	pop	de
	or	a, a
	sbc	hl, de
	ld	(ix+6), h
	add	hl, de
	add	hl, de
	ld	(ix+2), h
; next
	ld	hl, (iy+IQX)
	ld	de, (iy+IQW)
	IQuatMul
	rla
	adc	hl, hl
; 2*qx*qw
	push	hl
	ld	hl, (iy+IQY)
	ld	de, (iy+IQZ)
	IQuatMul
	rla
	adc	hl, hl
; 2*qy*qz
	pop	de
	or	a, a
	sbc	hl, de
	ld	(ix+5), h
	add	hl, de
	add	hl, de
	ld	(ix+7), h
; 1-2*qy²-2qz²
	ld	hl, (iy+IQY)
	IQuatSquare
	rla
	adc	hl, hl
	push	hl
	push	hl
	ld	hl, (iy+IQZ)
	IQuatSquare
	rla
	adc	hl, hl
	ex	de, hl
	pop	bc
	ld	hl, $004000
	or	a, a
	sbc	hl, bc
	or	a, a
	sbc	hl, de
	ld	(ix+0), h
; 1-2*qz²-2qx²	
	push	de
	ld	hl, (iy+IQX)
	IQuatSquare
	rla
	adc	hl, hl
	ex	de, hl
	pop	bc
	ld	hl, $004000
	or	a, a
	sbc	hl, bc
	or	a, a
	sbc	hl, de
	ld	(ix+4), h
; 1-2qx²-2qy²
	pop	bc
	ld	hl, $004000
	or	a, a
	sbc	hl, bc
	or	a, a
	sbc	hl, de
	ld	(ix+8), h
	ret
#endif
IQuaternionRotationAxis:
; iy adress of quaternion to write
; ix unit vector
; a angle
; qw = cos(angle/2)
; qx = axis.x*sin(angle/2)
; qy = axis.y*sin(angle/2)
; qz = axis.z*sin(angle/2)
	push	hl
	call	IQuatSin
; hl = sin
	ex	de, hl
; DE is never destroyed by the macro's
	ld	hl, (ix+0)
	IQuatMul
	ld	(iy+IQX), hl
	ld	hl, (ix+3)
	IQuatMul
	ld	(iy+IQY), hl
	ld	hl, (ix+6)
	IQuatMul
	ld	(iy+IQZ), hl
	pop	hl
	call	IQuatCos
	ld	(iy+IQW), hl
	ret
IQuatCos:
	inc	h
IQuatSin:
	bit	0, h
	ld	a, l
	jr	z, _IQuatSinSkp1
	neg
	jr	z, _IQuatIndexZero
_IQuatSinSkp1:
	bit	1, h
	jr	nz, _IQuatSinNegate
	ld	hl, ISIN_TABLE
	ld	l, a
	ld	c, (hl)
	inc	h
	ld	b, (hl)
	sbc	hl, hl
	ld	h, b
	ld	l, c
	ret
_IQuatSinNegate:
	ld	hl, ISIN_TABLE
	inc.s	bc
	ld	l, a
	ld	c, (hl)
	inc	h
	ld	b, (hl)
	sbc	hl, hl
	sbc	hl, bc
	ret
_IQuatIndexZero
	bit	1, h
	jr	nz, _IQuatNegResultCst
	ld	hl, $004000
	ret
_IQuatNegResultCst:
	ld	hl, $FFC000
	ret
#else
	.echo	"IrisQuaternion.ez80 version doesn't correspond to Iris3D.inc version"
#endif
